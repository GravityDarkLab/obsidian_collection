
-  `Cryptographic Hash Functions: CHF`
- `Message Authentication Codes: MAC`

- [[#Cryptographic Hash Functions|Cryptographic Hash Functions]]
	- [[#Cryptographic Hash Functions#Definition|Definition]]
	- [[#Cryptographic Hash Functions#Comparison to Cyclic Redundancy Checks (CRC)|Comparison to Cyclic Redundancy Checks (CRC)]]
	- [[#Cryptographic Hash Functions#Common Use Cases|Common Use Cases]]
- [[#Message Authentication Codes|Message Authentication Codes]]
	- [[#Message Authentication Codes#Definition|Definition]]
	- [[#Message Authentication Codes#Applications|Applications]]
	- [[#Message Authentication Codes#Common Use Cases:|Common Use Cases:]]
	- [[#Message Authentication Codes#Types of MACs:|Types of MACs:]]

## Cryptographic Hash Functions
>  `Purpose: To create a unique, fixed-size hash value (digest) from data (like a message)`.
### Definition 
- A function $h$ is called a **hash function** if:
	- $h$ maps an input $x$ of arbitrary length to an output $h (x)$ of fixed length $n$. 
		  $\rightarrow$ Compression.
	- $h$ must be a one-way function.
	- Impossible to distinguish the output of $h(x)$ from a random number.
	    $\rightarrow$ Random oracle property.
	- It is computationally infeasible to find any pair $(x, x’)$ with $x \ne x’$ such that $H (x) = H (x’)$
	    $\rightarrow$ Collision resistance.
### Comparison to Cyclic Redundancy Checks (CRC)
- Why not use CRC as a cryptographic hash function?
	- CRC **==does not provide==** $2^{nd}$ **==pre-image resistance and collision resistance==**
	- CRC is additive: 
		- Let us modify a message $x$ by computing $x \oplus \Delta$
		- $CRC(x) \oplus CRC (\Delta) = CRC(x \oplus \Delta)$
		- Problematic for instance in combination with stream ciphers.
 > - CRC is not a cryptographic hash function
 > - CRC is useful for protecting against noisy channels
 > - **But not against intentional manipulation**.

### Common Use Cases

- **Data Integrity**: Ensures data hasn’t been altered.
- **Password Storage**: Stores hash of the password, not the actual password.
- **Digital Fingerprints**: Unique identifier for large sets of data.

**Examples**: SHA-256, MD5 (though MD5 is now considered insecure due to vulnerabilities).



## Message Authentication Codes

> `Key-Dependent: The MAC value changes if the key changes`.
> 
> `Verification: The recipient, using the same key, can generate the MAC and compare it to the sent MAC to verify integrity and authenticity`.

### Definition 

**Purpose**: To authenticate a message and ensure its integrity and authenticity .

**How it Works**:
	1. A MAC is generated by taking the original message and a secret key as inputs. Using a specific MAC algorithm (like HMAC, CMAC, etc.), it produces a fixed-size output, known as the MAC tag or value.
	2. This tag is then attached to the message when it's sent over a network.
- The recipient, who also knows the secret key, can generate the MAC again using the received message and compare it with the received MAC tag. If they match, it confirms that the message has not been altered and is authentic
### Applications
![[Pasted image 20240103215632.png]]

![[Pasted image 20240103215514.png]]

### Common Use Cases:

- Data Integrity and Authentication: Ensures data is from the claimed source and hasn’t been altered.
- Secure Channels: Used in protocols like SSL/TLS for secure communication.
> For integrity/authenticity checks the receiver needs to know m and a secure modification check value that it can compare.

### Types of MACs:

- **[[HMAC (Hash-based MAC)]]**: Combines a cryptographic hash function with a secret key. For example, HMAC-SHA256.
- **[[CMAC (Cipher-based MAC)]]** / **[[CBC-MAC]]**: Uses a block cipher like AES for authentication.

## Why?
- Integrity.
- Authentication
- Non-Repudation
- `In essence, MACs are like a handshake agreement in digital form, ensuring that the message you receive is exactly as sent and comes from someone you trust`.